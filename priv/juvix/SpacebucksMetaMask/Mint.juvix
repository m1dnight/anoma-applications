module SpacebucksMetaMask.Mint;

import Stdlib.Prelude open;
import Applib open;
import Anoma.Encode open;
import Stdlib.Debug.Trace open;
import Anoma.Identity.External open;
import Anoma.Identity.Internal open;
import BaseLayer.ResourceMachine open;
import Anoma.Builtin.System as SystemBuiltins open;
import SpacebucksMetaMask.Helpers open;
import SpacebucksMetaMask.Signing open;
import Applib.Keccak256 open;
import Applib.Secp256k1 open;
import Stdlib.Debug.Fail open;

-- ----------------------------------------------------------------------------
--  Logic function

logicFunction (args : Logic.Args) : Bool := true;

-- ----------------------------------------------------------------------------
--  Create a transaction to mint some spacebucks.

create-spacebucks-transaction
  {M : Type -> Type}
  {{Monad M}}
  {{Tx M}}
  (appdata : AppData)
  (created-resource : Resource)
  (consumed-resource : Resource)
  (identity : ExternalIdentity)
  : M Transaction :=
  do {
    ctx <- getTxContext;
    nonce-created <- genRandomNonce;
    nonce-consumed <- genRandomNonce;
    let
      current-root : CommitmentRoot := TxContext.currentRoot ctx;

      rooted-nullifier := RootedNullifiableResource.Transparent.mk current-root consumed-resource;

      action : Action :=
        Action.create@{
                consumed := [rooted-nullifier];
                created := [created-resource];
                appData := appdata;
              };
      -- commitment roots
      commitment-roots := [current-root];

      -- roots
      roots := AnomaSet.fromList commitment-roots;
      actions := AnomaSet.fromList [action];

    in
    pure
      Transaction.mk@{
        roots := AnomaSet.fromList commitment-roots;
        actions := AnomaSet.fromList [action];
      };
  };

-- -----------------------------------------------------------
--  Verify the signature

verify-signed
  (message : AnomaAtom) (signature : AnomaAtom) (public-key : AnomaAtom) : Bool :=
  let
    message-nat : Nat := trace message >-> AnomaAtom.toNat message;
    signature-nat : Nat := trace signature >-> AnomaAtom.toNat signature;
    key : ExternalIdentity  := trace "yeet" >-> ExternalIdentity.fromAnomaAtom public-key;
    key-nat : Nat := AnomaAtom.toNat public-key;
  in trace "WORK DAMNIT" >-> trace key >-> Secp256k1.Private.verify message-nat signature-nat key-nat;

-- ----------------------------------------------------------------------------
--  Main function

-- The label of a spacebuck is what uniquely identifies it. If Bob makes a
-- spacebuck, it's uniquely identified by the pair
-- (bob_public_key, "spacebuck").
main
  (appdata : AnomaAtom)
  (message : AnomaAtom)
  (signature : AnomaAtom)
  (public-key : AnomaAtom)
  (current-root : CommitmentRoot)
  : TransactionRequest := trace "doing mint" >->
  if
    | not (verify-signed message signature public-key) :=
      failwith "invalid signature"
    | else :=
      trace "valid signature"
      >-> trace public-key
      >-> let
              -- decode the public key from the signer
              -- the identity of the user who signed to create the spacebucks
              identity : ExternalIdentity := ExternalIdentity.fromAnomaAtom public-key;

              -- decode the created and consumed resource the user signed over
              jammed-appdata : AnomaAtom := trace "identity" >-> trace identity >-> decode-atom appdata;
              (created-resource, consumed-resource) :  (Pair Resource Resource) := decode-atom jammed-appdata;

              -- create commitments and nullifiers
              commitments : List Commitment := trace "created resource" >-> trace created-resource >-> commitments-for-created [created-resource];
              nullifiers : List Nullifier := trace "consumed resource" >-> trace consumed-resource >-> nullifiers-for-consumed [consumed-resource];

              -- create the rooted nullifier
              current-root := CommitmentRoot.fromNat 0;
              rooted-nullifier := RootedNullifiableResource.Transparent.mk current-root consumed-resource;

              -- create the appdata
              app-data : AppData := create-app-data identity signature nullifiers commitments;

              -- create the action based on the appdata and resources
              action : Action :=
                Action.create@{
                  consumed := [rooted-nullifier];
                  created := [created-resource];
                  appData := app-data;
                };
              -- commitment roots
              commitment-roots := [current-root];

              -- roots
              roots := AnomaSet.fromList commitment-roots;
              actions := AnomaSet.fromList [action];

              -- create the transaction context which holds the caller and the current root
              context : TxContext :=
                TxContext.mk@{
                  caller := Universal.identity;
                  currentRoot := CommitmentRoot.fromNat 0;
                };
              transaction :=
                TransactionRequest.build
                  0
                  context
                  (create-spacebucks-transaction
                    app-data
                    created-resource
                    consumed-resource
                    identity);
            in trace "transaction" >-> transaction;